# -*- coding: utf-8 -*-
"""model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1krTmLawzQv_l2oR8CsnGtxLcsff4giDR
"""

!pip install catboost

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split, KFold
from catboost import CatBoostClassifier
from sklearn.metrics import accuracy_score, precision_score, confusion_matrix,recall_score,f1_score
from sklearn.preprocessing import LabelEncoder,MultiLabelBinarizer
from sklearn.preprocessing import StandardScaler

from google.colab import files
uploaded = files.upload()

df = pd.read_csv('pregnancy_health_data_7000_variety.csv')

df.info()

df['Supplements'].fillna('magnesium',inplace=True)
df['Symptoms'].fillna('dizziness',inplace=True)

df.drop(columns=['Trimester'],inplace=True)

df.head()

df['Supplements'].value_counts()

df['Physical_Activity'].value_counts()

df['Physical_Activity'].value_counts()

"""# **APPROACH:-**
1. Instead of creating target column directly jaha pe there was HIGH, LOW risk...this time have created 3 categories HIGH, LOW and MODERATE....also have tries adding noise in the data to make it a bit more realistic.

2. currently the accuracy is of 0.84, precision_score of 0.85, recall_score is of 0.84, f1_score of 0.84

3. Confusion Matrix shows that the model Misses many Lows (confused as Moderate)
"""

temp=df[df['Currently_Pregnant']=='Yes']

df.head(1)

def calculate_risk_score(row):
    score = 0

    if row['Sugary_Foods'] in ['Never', 'Rarely']:
        score -= 1
    else:
        score += 1

    if row['Supplement_Frequency'] == 'Daily':
        score -= 1
    elif row['Supplement_Frequency'] == 'Never':
        score += 1

    if row['Smoke_Alcohol'] == 'Yes':
        score += 2

    if row['Physical_Activity'] == 'High':
        score -= 1
    elif row['Physical_Activity'] == 'Low':
        score += 1

    return score

import random

def create_multiclass_output_with_noise(row):
    score = calculate_risk_score(row)

    # More randomness: 35% chance to flip score
    if random.random() < 0.35:
        score += random.choice([-1, 1])

    # Convert to multiclass risk
    if score <= 1:
        return 'Low'
    elif 1<score <= 5:
        return 'Moderate'
    else:
        return 'High'

random.choice([-1, 1])

temp['Pregnancy_Risk_Level'] = temp.apply(create_multiclass_output_with_noise, axis=1)

temp['Pregnancy_Risk_Level'].value_counts()

temp.head()

temp.drop(columns=['Currently_Pregnant'])

temp['Pregnancy_Risk_Level'] = temp['Pregnancy_Risk_Level'].map({'Low':0,'Moderate':1,'High':2})
train_df,test_df = train_test_split(temp,test_size=0.2,random_state=42,stratify = temp['Pregnancy_Risk_Level'])

binary_cols = ['Currently_Pregnant','Use_Fortified_Food','Smoke_Alcohol','Clean_Water','Food_Access_Difficulty']

for col in binary_cols:
  train_df[col] = train_df[col].map({'Yes':1,'No':0})
  test_df[col] = test_df[col].map({'Yes':1,'No':0})

temp.head()

cat_cols = [ 'Supplements', 'Fried_Foods', 'Sugary_Foods',
            'Supplement_Frequency', 'Avoiding_Foods', 'Symptoms', 'Physical_Activity']
target_col = 'Pregnancy_Risk_Level'

for col in cat_cols:
  train_df[f'{col}_te'] = pd.Series(index=train_df.index, dtype='float64')
  kf = KFold(n_splits=10, shuffle=True, random_state=42)

  for train_index, val_index in kf.split(train_df):
    fold_train = train_df.iloc[train_index]
    fold_val = train_df.iloc[val_index]

    means = fold_train.groupby(col)['Pregnancy_Risk_Level'].mean()
    train_df.loc[train_df.index[val_index],f'{col}_te'] = fold_val[col].map(means)

  train_df[f'{col}_te'].fillna(train_df[target_col].mean(), inplace=True)
  test_means = train_df.groupby(col)[target_col].mean()
  test_df[f'{col}_te'] = test_df[col].map(test_means)
  test_df[f'{col}_te'].fillna(train_df[target_col].mean(), inplace=True)

features = binary_cols + [f"{col}_te" for col in cat_cols] + ['Age', 'Height_cm', 'Weight_kg', 'Water_Intake_L', 'Previous_Pregnancies']

X_train = train_df[features]
y_train = train_df[target_col]
X_test = test_df[features]
y_test = test_df[target_col]

model = CatBoostClassifier(
    iterations=300,
    depth=3,
    learning_rate=0.01,
    l2_leaf_reg=10,
    early_stopping_rounds=25,
    eval_metric='Accuracy',
    verbose=100
)

model.fit(X_train,y_train)

y_pred = model.predict(X_test)

accuracy_score(y_test,y_pred)

confusion_matrix(y_test,y_pred)

precision_score(y_test,y_pred,average='weighted')

recall_score(y_test,y_pred,average='weighted')

f1_score(y_test,y_pred,average='weighted')

"""# **Approach 2**"""

data = df.copy()

data.head()

from sklearn.preprocessing import MultiLabelBinarizer

mlb = MultiLabelBinarizer()

df['Food_Options_Available'] = df['Food_Options_Available'].apply(lambda x: x.split(','))

food = mlb.fit_transform(df['Food_Options_Available'])

food_df = pd.DataFrame(food,columns=mlb.classes_)

df_final = pd.concat([data,food_df],axis=1)

df_final.head(1)

df_final=df_final[df_final['Currently_Pregnant']=='Yes']

df_final.columns

df_final.drop(columns=['Currently_Pregnant','Use_Fortified_Food','Food_Options_Available',' black-eyed peas',' chicken',' egg',' eggs',' fish',' ghee',' kiwi',
                       ' lentils',' milkshake',' mung beans',' mutton',' none',' pear',' pineapple'	,' plum'	,' prawns',' sardines',' red lentils',' tofu',' turkey',' whey',
                       ],inplace=True)

df_final.head()

df_final[' curd'] = df_final[' curd'] | df_final[' yogurt']

df_final.drop(columns=[' yogurt'],inplace=True)

df_final.head()

df_final.drop(columns=['papaya',' orange',' grapes'],inplace=True)

df_final.drop(columns=[' green gram'],inplace=True)

# df_final['palak'] = df_final['palak'] | df_final['spinach']
# df_final[' rajma'] = df_final[' rajma'] | df_final[' kidney beans']
df_final[' buttermilk'] = df_final[' buttermilk'] | df_final[' lassi']

df_final.drop(columns=['spinach',' kidney beans','zucchini'],inplace=True)

# df_final.drop(columns=[' lassi','pumpkin'],inplace=True)
df_final.drop(columns=[' figs','broccoli'],inplace=True)

def calculate_risk_score(row):
    score = 0

    if row['Sugary_Foods'] in ['Never', 'Rarely']:
        score -= 1
    else:
        score += 1

    if row['Supplement_Frequency'] == 'Daily':
        score -= 1
    elif row['Supplement_Frequency'] == 'Never':
        score += 1

    if row['Smoke_Alcohol'] == 'Yes':
        score += 2

    if row['Physical_Activity'] == 'High':
        score -= 1
    elif row['Physical_Activity'] == 'Low':
        score += 1
    if row['Water_Intake_L']>=2:
      score -=1
    else:
      score +=1

    if ((row[' apple'] ==1) or (row[' banana']==1) or (row[' guava']==1) or (row[' watermelon']==1) or (row['mango']==1)):
      score -=1
    else:
      score +=1
    if ((row[' curd'] ==1) or (row[' milk']==1) or (row[' buttermilk']==1) or (row[' cheese']==1) or (row[' paneer']==1)):
      score -=1
    else:
      score +=1
    if ((row[' masoor dal'] ==1) or (row[' chana dal']==1) or (row[' moong dal']==1) or (row[' toor dal']==1) or  (row[' urad dal']==1)):
      score -=1
    else:
      score +=1
    if ((row[' rajma'] ==1) or (row[' soybeans']==1) or (row[' sprouts']==1) or (row[' chickpeas']==1)):
      score -=1
    else:
      score +=1
    if ((row['palak'] ==1) or (row['beetroot']==1) or (row[' dates']==1)):
      score -=1
    else:
      score +=1
    if ((row['sweet potato'] ==1) or (row['carrot']==1) or (row['tomato']==1)):
      score -=1
    else:
      score +=1
    if ((row['lauki'] ==1) or (row['cucumber']==1)):
      score -=1
    else:
      score +=1

    return score



import random
a = []
def create_multiclass_output_with_noise(row):
    score = calculate_risk_score(row)

    a.append(score)

    # More randomness: 35% chance to flip score
    # if random.random() < 0.40:
    #     score += random.choice([-1, 1])

    # # Convert to multiclass risk
    if score <=0:
        return 'Low'
    # elif -1<score <= 1:
    #     return 'Moderate'
    else:
        return 'High'

df_final['Pregnancy_Risk_Level'] = df_final.apply(create_multiclass_output_with_noise, axis=1)



df_final['Pregnancy_Risk_Level'].value_counts()

print(a)

unique_values = list(set(a))
print(unique_values)

df_final['Pregnancy_Risk_Level'] = df_final['Pregnancy_Risk_Level'].map({'Low':0,'Moderate':1,'High':2})
train_df,test_df = train_test_split(df_final,test_size=0.2,random_state=42,stratify = df_final['Pregnancy_Risk_Level'])

binary_cols = ['Smoke_Alcohol','Clean_Water','Food_Access_Difficulty']

for col in binary_cols:
  train_df[col] = train_df[col].map({'Yes':1,'No':0})
  test_df[col] = test_df[col].map({'Yes':1,'No':0})

cat_cols = [ 'Supplements', 'Fried_Foods', 'Sugary_Foods',
            'Supplement_Frequency', 'Avoiding_Foods', 'Symptoms', 'Physical_Activity']
target_col = 'Pregnancy_Risk_Level'

for col in cat_cols:
  train_df[f'{col}_te'] = pd.Series(index=train_df.index, dtype='float64')
  kf = KFold(n_splits=10, shuffle=True, random_state=42)

  for train_index, val_index in kf.split(train_df):
    fold_train = train_df.iloc[train_index]
    fold_val = train_df.iloc[val_index]

    means = fold_train.groupby(col)['Pregnancy_Risk_Level'].mean()
    train_df.loc[train_df.index[val_index],f'{col}_te'] = fold_val[col].map(means)

  train_df[f'{col}_te'].fillna(train_df[target_col].mean(), inplace=True)
  test_means = train_df.groupby(col)[target_col].mean()
  test_df[f'{col}_te'] = test_df[col].map(test_means)
  test_df[f'{col}_te'].fillna(train_df[target_col].mean(), inplace=True)

features = binary_cols + [f"{col}_te" for col in cat_cols] + ['Age', 'Height_cm', 'Weight_kg', 'Water_Intake_L', 'Previous_Pregnancies']

X_train = train_df[features]
y_train = train_df[target_col]
X_test = test_df[features]
y_test = test_df[target_col]

# from imblearn.over_sampling import SMOTE

# smote = SMOTE(random_state=42)
# X_train, y_train = smote.fit_resample(X_train, y_train)

model = CatBoostClassifier(
    iterations=1000,
    depth=6,
    learning_rate=0.01,
    early_stopping_rounds=20,
    eval_metric='Accuracy',
    verbose=100
)

model.fit(X_train,y_train)

y_pred = model.predict(X_test)

accuracy_score(y_test,y_pred)

from sklearn.metrics import classification_report

print(classification_report(y_test,y_pred))

df_final['Pregnancy_Risk_Level'].value_counts()

